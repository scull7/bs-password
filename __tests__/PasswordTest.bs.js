// Generated by BUCKLESCRIPT VERSION 3.1.5, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Future = require("reason-future/src/Future.bs.js");
var Password = require("../src/Password.bs.js");
var Password_future = require("../src/Password_future.bs.js");
var Password_promise = require("../src/Password_promise.bs.js");

function failTest(finished, e) {
  return Curry._1(finished, Jest.fail(String(e)));
}

describe("Bcrypt", (function () {
        Jest.testAsync(/* None */0, "derive and verify key - PASS", (function (finished) {
                var input = "this is a test";
                return Password.deriveKey(/* Bcrypt */0, input, (function (result) {
                              if (result.tag) {
                                return Curry._1(finished, Jest.fail(String(result[0])));
                              } else {
                                return Password.verify(/* Bcrypt */0, result[0][1], input, (function (param) {
                                              if (param.tag) {
                                                return Curry._1(finished, Jest.fail(String(param[0])));
                                              } else {
                                                return Curry._1(finished, Jest.Expect[/* toBe */2](true, Jest.Expect[/* expect */0](param[0])));
                                              }
                                            }));
                              }
                            }));
              }));
        Jest.testAsync(/* None */0, "derive and verify key - FAIL", (function (finished) {
                return Password.deriveKey(/* Bcrypt */0, "this is a failing test", (function (result) {
                              if (result.tag) {
                                return Curry._1(finished, Jest.fail(String(result[0])));
                              } else {
                                return Password.verify(/* Bcrypt */0, result[0][1], "this is not a failing test", (function (param) {
                                              if (param.tag) {
                                                return Curry._1(finished, Jest.fail(String(param[0])));
                                              } else {
                                                return Curry._1(finished, Jest.Expect[/* toBe */2](false, Jest.Expect[/* expect */0](param[0])));
                                              }
                                            }));
                              }
                            }));
              }));
        return Jest.testAsync(/* None */0, "Generate a token of a given length", (function (finished) {
                      var re = (/^\$2a\$08\$/);
                      return Password.token(/* Bcrypt */0, 8, (function (result) {
                                    if (result.tag) {
                                      return Curry._1(finished, Jest.fail(String(result[0])));
                                    } else {
                                      return Curry._1(finished, Jest.Expect[/* toMatchRe */15](re, Jest.Expect[/* expect */0](result[0])));
                                    }
                                  }));
                    }));
      }));

describe("Bcrypt - Future", (function () {
        Jest.testAsync(/* None */0, "Derive and verify a key - PASS", (function (finished) {
                var input = "The future is now!";
                Future.mapError(Future.mapOk(Future.mapOk(Future.flatMapOk(Password_future.deriveKey(/* Bcrypt */0, input), (function (param) {
                                    return Password_future.verify(/* Bcrypt */0, param[1], input);
                                  })), (function (valid) {
                                return Jest.Expect[/* toBe */2](true, Jest.Expect[/* expect */0](valid));
                              })), finished), (function (param) {
                        return Curry._1(finished, Jest.fail(String(param)));
                      }));
                return /* () */0;
              }));
        Jest.testAsync(/* None */0, "Derive and verify a key - PASS", (function (finished) {
                Future.mapError(Future.mapOk(Future.mapOk(Future.flatMapOk(Password_future.deriveKey(/* Bcrypt */0, "The future is now!"), (function (param) {
                                    return Password_future.verify(/* Bcrypt */0, param[1], "The future is the past");
                                  })), (function (valid) {
                                return Jest.Expect[/* toBe */2](false, Jest.Expect[/* expect */0](valid));
                              })), finished), (function (param) {
                        return Curry._1(finished, Jest.fail(String(param)));
                      }));
                return /* () */0;
              }));
        return Jest.testAsync(/* None */0, "Generate a token of a given length", (function (finish) {
                      var re = (/^\$2a\$16\$/);
                      Future.mapError(Future.mapOk(Future.mapOk(Password_future.token(/* Bcrypt */0, 16), (function (token) {
                                      return Jest.Expect[/* toMatchRe */15](re, Jest.Expect[/* expect */0](token));
                                    })), Curry.__1(finish)), (function (param) {
                              return Curry._1(finish, Jest.fail(String(param)));
                            }));
                      return /* () */0;
                    }));
      }));

describe("Bcrypt - Promise", (function () {
        var input = "The future is now!";
        Jest.testPromise(/* None */0, "Derive and verify a key - PASS", (function () {
                return Password_promise.deriveKey(/* Bcrypt */0, input).then((function (result) {
                                if (result.tag) {
                                  return Promise.resolve(/* Error */Block.__(1, [result[0]]));
                                } else {
                                  return Password_promise.verify(/* Bcrypt */0, result[0][1], input);
                                }
                              })).then((function (result) {
                              var tmp;
                              tmp = result.tag ? Jest.fail(String(result[0])) : Jest.Expect[/* toBe */2](true, Jest.Expect[/* expect */0](result[0]));
                              return Promise.resolve(tmp);
                            }));
              }));
        Jest.testPromise(/* None */0, "Derive and verify a key - FAIL", (function () {
                return Password_promise.deriveKey(/* Bcrypt */0, input).then((function (result) {
                                if (result.tag) {
                                  return Promise.resolve(/* Error */Block.__(1, [result[0]]));
                                } else {
                                  return Password_promise.verify(/* Bcrypt */0, result[0][1], "I promise this works.");
                                }
                              })).then((function (result) {
                              var tmp;
                              tmp = result.tag ? Jest.fail(String(result[0])) : Jest.Expect[/* toBe */2](false, Jest.Expect[/* expect */0](result[0]));
                              return Promise.resolve(tmp);
                            }));
              }));
        return Jest.testPromise(/* None */0, "Generate a token of a given length", (function () {
                      var re = (/^\$2a\$31\$/);
                      return Password_promise.token(/* Bcrypt */0, 42).then((function (result) {
                                    var tmp;
                                    tmp = result.tag ? Jest.fail(String(result[0])) : Jest.Expect[/* toMatchRe */15](re, Jest.Expect[/* expect */0](result[0]));
                                    return Promise.resolve(tmp);
                                  }));
                    }));
      }));

exports.failTest = failTest;
/*  Not a pure module */
